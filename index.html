<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gerrymandering Grid</title>
<style>
Â  body {
Â  Â  font-family: Arial, sans-serif;
Â  Â  text-align: center;
Â  Â  padding: 20px;
Â  }
Â  .controls {
Â  Â  margin-bottom: 15px;
Â  }
Â  .grid {
Â  Â  display: grid;
Â  Â  grid-template-columns: repeat(4, 60px);
Â  Â  grid-template-rows: repeat(4, 60px);
Â  Â  /* Remove gap, borders will handle separation */
Â  Â  justify-content: center;
Â  Â  margin: 0 auto;
Â  }
Â  .cell {
Â  Â  width: 60px;
Â  Â  height: 60px;
Â  Â  /* Base border for all cells - serves as the white gap */
Â  Â  border: 3px solid white; 
Â  Â  box-sizing: border-box; /* Crucial for border to be inclusive of width/height */
Â  Â  cursor: pointer;
Â  Â  transition: 0.2s;
Â  Â  /* Set up default/reset borders */
Â  Â  border-color: white;
Â  }
Â  .blue { background-color: #3b82f6; } /* Tailwind blue-500 */
Â  .red { background-color: #ef4444; }Â  /* Tailwind red-500 */

Â  /* Define district border colors */
Â  .subgrid-1-border { border-color: black !important; }
Â  .subgrid-2-border { border-color: green !important; }
Â  .subgrid-3-border { border-color: yellow !important; }

Â  /* Specific border assignments for shared boundaries */
Â  .cell[data-subgrid='1'] { border-color: white; }
Â  .cell[data-subgrid='2'] { border-color: white; }
Â  .cell[data-subgrid='3'] { border-color: white; }

Â  .subgrid-1-top { border-top-color: black !important; }
Â  .subgrid-1-right { border-right-color: black !important; }
Â  .subgrid-1-bottom { border-bottom-color: black !important; }
Â  .subgrid-1-left { border-left-color: black !important; }

Â  .subgrid-2-top { border-top-color: green !important; }
Â  .subgrid-2-right { border-right-color: green !important; }
Â  .subgrid-2-bottom { border-bottom-color: green !important; }
Â  .subgrid-2-left { border-left-color: green !important; }

Â  .subgrid-3-top { border-top-color: yellow !important; }
Â  .subgrid-3-right { border-right-color: yellow !important; }
Â  .subgrid-3-bottom { border-bottom-color: yellow !important; }
Â  .subgrid-3-left { border-left-color: yellow !important; }


Â  #message, #winner {
Â  Â  margin-top: 15px;
Â  Â  font-weight: bold;
Â  }
Â  #message { color: red; }
Â  #winner { color: #111; }
</style>
</head>
<body>
Â  <h1>Gerrymandering Interactive Grid</h1>
Â  <p>Select a subgrid, then click tiles to assign them. Each subgrid must be contiguous.</p>

Â  <div class="controls">
Â  Â  <label><input type="radio" name="subgrid" value="1" checked> Subgrid 1</label>
Â  Â  <label><input type="radio" name="subgrid" value="2"> Subgrid 2</label>
Â  Â  <label><input type="radio" name="subgrid" value="3"> Subgrid 3</label>
Â  </div>

Â  <div class="grid" id="grid"></div>
Â  <div id="message"></div>
Â  <div id="winner"></div>

<script>
const grid = document.getElementById('grid');
const rows = ['A', 'B', 'C', 'D'];
const cols = ['1', '2', '3', '4'];
const blueTiles = new Set(['A1', 'A3', 'B4', 'D1', 'D2', 'D3']);
let selectedSubgrid = '1';
const gridSize = 4; // 4x4 grid

// Array to hold cell elements in a 2D structure for easier neighbor lookup
const cellMatrix = [];

// Build grid
for (let r = 0; r < gridSize; r++) {
Â  const row = rows[r];
Â  cellMatrix[r] = [];
Â  for (let c = 0; c < gridSize; c++) {
Â  Â  const col = cols[c];
Â  Â  const id = row + col;
Â  Â  const cell = document.createElement('div');
Â  Â  cell.classList.add('cell', blueTiles.has(id) ? 'blue' : 'red');
Â  Â  cell.dataset.id = id;
Â  Â  cell.dataset.row = row;
Â  Â  cell.dataset.col = col;
Â  Â  cell.dataset.subgrid = '';
Â  Â  cell.dataset.ridx = r; // Row index
Â  Â  cell.dataset.cidx = c; // Column index
Â  Â  grid.appendChild(cell);
Â  Â  cellMatrix[r][c] = cell;
Â  }
}

// Handle subgrid selection
document.querySelectorAll('input[name="subgrid"]').forEach(input => {
Â  input.addEventListener('change', e => selectedSubgrid = e.target.value);
});

// Helper to remove all border classes from a cell
function resetCellBorders(cell) {
Â  cell.classList.remove(
Â  Â  'subgrid-1-top', 'subgrid-1-right', 'subgrid-1-bottom', 'subgrid-1-left',
Â  Â  'subgrid-2-top', 'subgrid-2-right', 'subgrid-2-bottom', 'subgrid-2-left',
Â  Â  'subgrid-3-top', 'subgrid-3-right', 'subgrid-3-bottom', 'subgrid-3-left'
Â  );
}

// Function to apply district borders based on neighbors
function applyBorders() {
Â  for (let r = 0; r < gridSize; r++) {
Â  Â  for (let c = 0; c < gridSize; c++) {
Â  Â  Â  const cell = cellMatrix[r][c];
Â  Â  Â  resetCellBorders(cell); // Clear existing borders
Â  Â  Â  const subgrid = cell.dataset.subgrid;

Â  Â  Â  if (subgrid === '') continue; // Skip unassigned tiles

Â  Â  Â  const borders = {
Â  Â  Â  Â  top: r > 0 ? cellMatrix[r - 1][c].dataset.subgrid : null,
Â  Â  Â  Â  right: c < gridSize - 1 ? cellMatrix[r][c + 1].dataset.subgrid : null,
Â  Â  Â  Â  bottom: r < gridSize - 1 ? cellMatrix[r + 1][c].dataset.subgrid : null,
Â  Â  Â  Â  left: c > 0 ? cellMatrix[r][c - 1].dataset.subgrid : null
Â  Â  Â  };

Â  Â  Â  // Check against boundaries (null means outside the grid)
Â  Â  Â  if (borders.top !== subgrid) cell.classList.add(`subgrid-${subgrid}-top`);
Â  Â  Â  if (borders.right !== subgrid) cell.classList.add(`subgrid-${subgrid}-right`);
Â  Â  Â  if (borders.bottom !== subgrid) cell.classList.add(`subgrid-${subgrid}-bottom`);
Â  Â  Â  if (borders.left !== subgrid) cell.classList.add(`subgrid-${subgrid}-left`);
Â  Â  }
Â  }
}

// Handle cell clicks
grid.addEventListener('click', e => {
Â  if (!e.target.classList.contains('cell')) return;
Â  const cell = e.target;
Â  const prev = cell.dataset.subgrid;

Â  // Clear old border class before changing subgrid assignment
Â  resetCellBorders(cell);

Â  if (prev === selectedSubgrid) {
Â  Â  // Unassign
Â  Â  cell.dataset.subgrid = '';
Â  } else {
Â  Â  // Assign
Â  Â  cell.dataset.subgrid = selectedSubgrid;
Â  }
Â  
Â  validateSubgrids();
Â  applyBorders(); // Apply borders after assignment and validation
});

// Helper to check connectivity and compute results
function validateSubgrids() {
Â  const cells = [...document.querySelectorAll('.cell')];
Â  const message = document.getElementById('message');
Â  const winnerMsg = document.getElementById('winner');
Â  message.textContent = '';
Â  winnerMsg.textContent = '';

Â  // Connectivity validation (original logic remains the same)
Â  for (let subgridNum of ['1', '2', '3']) {
Â  Â  const assigned = cells.filter(c => c.dataset.subgrid === subgridNum);
Â  Â  if (assigned.length <= 1) continue; // single or none = valid

Â  Â  const coords = assigned.map(c => {
Â  Â  Â  const r = parseInt(c.dataset.ridx);
Â  Â  Â  const cidx = parseInt(c.dataset.cidx);
Â  Â  Â  return [r, cidx];
Â  Â  });

Â  Â  const visited = new Set();
Â  Â  const queue = [coords[0].join(',')];
Â  Â  visited.add(coords[0].join(','));

Â  Â  while (queue.length) {
Â  Â  Â  const [r, c] = queue.shift().split(',').map(Number);
Â  Â  Â  [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr, dc]) => {
Â  Â  Â  Â  const nr = r + dr, nc = c + dc;
Â  Â  Â  Â  const key = nr + ',' + nc;
Â  Â  Â  Â  if (nr < 0 || nr >= gridSize || nc < 0 || nc >= gridSize) return;
Â  Â  Â  Â  if (!visited.has(key) && coords.some(([rr, cc]) => rr === nr && cc === nc)) {
Â  Â  Â  Â  Â  visited.add(key);
Â  Â  Â  Â  Â  queue.push(key);
Â  Â  Â  Â  }
Â  Â  Â  });
Â  Â  }

Â  Â  if (visited.size !== coords.length) {
Â  Â  Â  message.textContent = `âŒ Invalid subgrid ${subgridNum}: tiles must be connected!`;
Â  Â  Â  winnerMsg.textContent = '';
Â  Â  Â  return;
Â  Â  }
Â  }

Â  message.textContent = 'âœ… All subgrids valid.';
Â Â 
Â  // Compute subgrid winners (original logic remains the same)
Â  const subgridResults = {1: null, 2: null, 3: null};
Â  for (let subgridNum of ['1', '2', '3']) {
Â  Â  const assigned = cells.filter(c => c.dataset.subgrid === subgridNum);
Â  Â  if (assigned.length === 0) continue;

Â  Â  const blueCount = assigned.filter(c => c.classList.contains('blue')).length;
Â  Â  const redCount = assigned.length - blueCount;

Â  Â  if (blueCount > redCount) subgridResults[subgridNum] = 'blue';
Â  Â  else if (redCount > blueCount) subgridResults[subgridNum] = 'red';
Â  Â  else subgridResults[subgridNum] = 'tie';
Â  }

Â  // Count overall wins (original logic remains the same)
Â  const blueWins = Object.values(subgridResults).filter(v => v === 'blue').length;
Â  const redWins = Object.values(subgridResults).filter(v => v === 'red').length;

Â  if (blueWins >= 2) {
Â  Â  winnerMsg.textContent = 'ğŸ† Blue wins overall!';
Â  Â  winnerMsg.style.color = '#2563eb';
Â  } else if (redWins >= 2) {
Â  Â  winnerMsg.textContent = 'ğŸ† Red wins overall!';
Â  Â  winnerMsg.style.color = '#dc2626';
Â  } else {
Â  Â  winnerMsg.textContent = 'ğŸ¤ It\'s a tie overall!';
Â  Â  winnerMsg.style.color = '#111';
Â  }
}

// Initial border application
applyBorders(); 
</script>
</body>
</html>