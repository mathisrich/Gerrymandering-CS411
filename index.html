<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gerrymandering Grid</title>
<style>
  body {
    font-family: Arial, sans-serif;
    text-align: center;
    padding: 20px;
  }
  .controls {
    margin-bottom: 15px;
  }
  .grid {
    display: grid;
    grid-template-columns: repeat(5, 60px);
    grid-template-rows: repeat(5, 60px);
    gap: 0;               /* tiles touch each other */
    justify-content: center;
    margin: 0 auto;
  }
  .cell {
    position: relative;
    width: 60px;
    height: 60px;
    box-sizing: border-box;
    border: 1px solid #aaa;          /* thin neutral grid line */
    cursor: pointer;
    transition: transform 0.1s;      /* press animation only */
  }
  /* Press straight down, no diagonal */
  .cell:active {
    transform: translateY(2px);
  }

  .blue { background-color: #3b82f6; }
  .red  { background-color: #ef4444; }

  #message, #winner {
    margin-top: 15px;
    font-weight: bold;
  }
  #message { color: red; }
  #winner  { color: #111; }
</style>
</head>
<body>
  <!-- Instructions screen -->
  <div id="intro" style="max-width: 700px; margin: 0 auto 20px; text-align: left;">
    <h1>Instructions for PS activity</h1>
    <p>You are McDonald Chumb, an ambitious and sharp strategist working for
       Barage Obana, a presidential candidate in a closely contested election.
       Your job: redraw the district map before the next vote.</p>

    <p>On the screen, youâ€™ll see a grid of voters, shown in two colors:
       <strong>blue</strong> and <strong>red</strong>. Each square is one voter.
       <strong>Blue</strong> voters support Barage Obana; <strong>red</strong> voters
       do not vote for Barage Obana. Your task is to divide the territory into a
       fixed number of districts. In each district, the majority color wins the seat.</p>

    <ul>
      <li><strong>Round 1 â€“ Fair map:</strong> draw districts so that the seats
          honestly reflect the overall distribution of voters.</li>
      <li><strong>Round 2 â€“ Biased map:</strong> redraw the districts to help
          your side win as many seats as possible.</li>
    </ul>

    <button id="startBtn">Start round 1</button>
  </div>

  <!-- Game screen -->
  <div id="game" style="display:none;">
    <h1>Gerrymandering Interactive Grid</h1>
    <p>Blue squares are voters for <strong>Barage Obana</strong>. Red squares are voters
       who <strong>do not</strong> vote for Barage Obana.</p>
    <p>Select a district, then click tiles to assign them. Each district must be contiguous.</p>
    <p>Try to make both sides win once, play with the districts!</p>

    <button id="resetBtn" style="margin-bottom:15px; padding:10px 20px; font-size:16px;">
      Reset Game
    </button>
    <button id="showStoryBtn" style="margin-bottom:15px; padding:10px 20px; font-size:16px; margin-left:10px;">
      Show story again
    </button>

    <div class="controls">
      <label><input type="radio" name="subgrid" value="1" checked> District 1</label>
      <label><input type="radio" name="subgrid" value="2"> District 2</label>
      <label><input type="radio" name="subgrid" value="3"> District 3</label>
    </div>

    <div class="grid" id="grid"></div>
    <div id="message"></div>
    <div id="winner"></div>
  </div>

  <script>
    const grid = document.getElementById('grid');
    const rows = ['A', 'B', 'C', 'D', 'E'];
    const cols = ['1', '2', '3', '4', '5'];
    const intro = document.getElementById('intro');
    const game = document.getElementById('game');
    const startBtn = document.getElementById('startBtn');
    const showStoryBtn = document.getElementById('showStoryBtn');
    const resetBtn = document.getElementById('resetBtn');

    const blueTiles = new Set(['A1', 'A3','B3', 'B5', 'B4', 'D1', 'D2', 'D3','E3','E4','C2']);

    let selectedSubgrid = '1';

    // Map from cell id (e.g. "A1") to element for fast neighbor lookup
    const cellById = {};

    // Build grid
    rows.forEach(r => {
      cols.forEach(c => {
        const id = r + c;
        const cell = document.createElement('div');
        cell.classList.add('cell', blueTiles.has(id) ? 'blue' : 'red');
        cell.dataset.id = id;
        cell.dataset.row = r;
        cell.dataset.col = c;
        cell.dataset.subgrid = '';
        grid.appendChild(cell);
        cellById[id] = cell;
      });
    });

    // Handle subgrid selection
    document.querySelectorAll('input[name="subgrid"]').forEach(input => {
      input.addEventListener('change', e => selectedSubgrid = e.target.value);
    });

    // Handle cell clicks
    grid.addEventListener('click', e => {
      if (!e.target.classList.contains('cell')) return;
      const cell = e.target;
      const prev = cell.dataset.subgrid;

      // If this tile already belongs to another district, ignore the click
      if (prev && prev !== selectedSubgrid) {
        return;
      }

      // Toggle membership for the currently selected district
      if (prev === selectedSubgrid) {
        // remove from this district
        cell.dataset.subgrid = '';
        cell.classList.remove(`subgrid-${selectedSubgrid}`);
      } else {
        // assign to this district (was unassigned)
        cell.dataset.subgrid = selectedSubgrid;
        cell.classList.add(`subgrid-${selectedSubgrid}`);
      }

      validateSubgrids();
    });

    // Reset button
    resetBtn.addEventListener('click', () => {
      const cells = document.querySelectorAll('.cell');
      cells.forEach(cell => {
        cell.dataset.subgrid = '';
        cell.classList.remove('subgrid-1', 'subgrid-2', 'subgrid-3');
      });
      document.getElementById('message').textContent = '';
      document.getElementById('winner').textContent = '';
      updateDistrictBorders();  // clear any thick borders
    });

    // Update borders so that each district has a single merged outline
    function updateDistrictBorders() {
      const cells = [...document.querySelectorAll('.cell')];

      // 1) Reset all borders to thin grey grid
      cells.forEach(cell => {
        cell.style.borderTop    = '1px solid #aaa';
        cell.style.borderRight  = '1px solid #aaa';
        cell.style.borderBottom = '1px solid #aaa';
        cell.style.borderLeft   = '1px solid #aaa';
      });

      const colors = {
        1: 'black',
        2: 'rgb(0, 255, 34)',
        3: 'rgb(255, 255, 0)'
      };

      const thick = '6px';  // thicker outline

      // 2) For each district, set merged outline
      for (let subgridNum of ['1', '2', '3']) {
        const color = colors[subgridNum];
        const assigned = cells.filter(c => c.dataset.subgrid === subgridNum);
        if (assigned.length === 0) continue;

        for (const cell of assigned) {
          const rowIndex = rows.indexOf(cell.dataset.row);
          const colIndex = cols.indexOf(cell.dataset.col);

          // Helper to get neighbor
          const getCell = (ri, ci) => {
            if (ri < 0 || ri >= rows.length || ci < 0 || ci >= cols.length) return null;
            const id = rows[ri] + cols[ci];
            return cellById[id] || null;
          };

          // TOP side
          let neighbor = getCell(rowIndex - 1, colIndex);
          if (!neighbor || neighbor.dataset.subgrid !== subgridNum) {
            cell.style.borderTop = `${thick} solid ${color}`;
          } else {
            // internal edge: remove border on both sides
            cell.style.borderTop = '1px solid #aaa';
            neighbor.style.borderBottom = '1px solid #aaa';
          }

          // BOTTOM side
          neighbor = getCell(rowIndex + 1, colIndex);
          if (!neighbor || neighbor.dataset.subgrid !== subgridNum) {
            cell.style.borderBottom = `${thick} solid ${color}`;
          } else {
            cell.style.borderBottom = '1px solid #aaa';
            neighbor.style.borderTop = '1px solid #aaa';
          }

          // LEFT side
          neighbor = getCell(rowIndex, colIndex - 1);
          if (!neighbor || neighbor.dataset.subgrid !== subgridNum) {
            cell.style.borderLeft = `${thick} solid ${color}`;
          } else {
            cell.style.borderLeft = '1px solid #aaa';
            neighbor.style.borderRight = '1px solid #aaa';
          }

          // RIGHT side
          neighbor = getCell(rowIndex, colIndex + 1);
          if (!neighbor || neighbor.dataset.subgrid !== subgridNum) {
            cell.style.borderRight = `${thick} solid ${color}`;
          } else {
            cell.style.borderRight = '0';
            neighbor.style.borderLeft = '0';
          }
        }
      }
    }

    // Validate connectivity + determine winners
    function validateSubgrids() {
      const cells = [...document.querySelectorAll('.cell')];
      const message = document.getElementById('message');
      const winnerMsg = document.getElementById('winner');
      message.textContent = '';
      winnerMsg.textContent = '';

      // Update borders first so visual stays in sync
      updateDistrictBorders();

      for (let subgridNum of ['1', '2', '3']) {
        const assigned = cells.filter(c => c.dataset.subgrid === subgridNum);
        if (assigned.length <= 1) continue;

        const coords = assigned.map(c => {
          return [
            rows.indexOf(c.dataset.row),
            cols.indexOf(c.dataset.col)
          ];
        });

        const visited = new Set();
        const queue = [coords[0].join(',')];
        visited.add(coords[0].join(','));

        while (queue.length) {
          const [r, c] = queue.shift().split(',').map(Number);
          [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr, dc]) => {
            const nr = r + dr, nc = c + dc;
            const key = nr + ',' + nc;
            if (nr < 0 || nr >= 5 || nc < 0 || nc >= 5) return;
            if (!visited.has(key) && coords.some(([rr, cc]) => rr === nr && cc === nc)) {
              visited.add(key);
              queue.push(key);
            }
          });
        }

        if (visited.size !== coords.length) {
          message.textContent = `âŒ Invalid district ${subgridNum}: tiles must be connected!`;
          winnerMsg.textContent = '';
          return;
        }
      }

      message.textContent = 'âœ… All districts valid.';

      // Compute subgrid winners
      const subgridResults = {1: null, 2: null, 3: null};
      for (let subgridNum of ['1', '2', '3']) {
        const assigned = cells.filter(c => c.dataset.subgrid === subgridNum);
        if (assigned.length === 0) continue;

        const blueCount = assigned.filter(c => c.classList.contains('blue')).length;
        const redCount = assigned.length - blueCount;

        if (blueCount > redCount) subgridResults[subgridNum] = 'blue';
        else if (redCount > blueCount) subgridResults[subgridNum] = 'red';
        else subgridResults[subgridNum] = 'tie';
      }

      // Overall winner
      const blueWins = Object.values(subgridResults).filter(v => v === 'blue').length;
      const redWins  = Object.values(subgridResults).filter(v => v === 'red').length;

      if (blueWins >= 2) {
        winnerMsg.textContent = 'ðŸ† Blue wins overall!';
        winnerMsg.style.color = '#2563eb';
      } else if (redWins >= 2) {
        winnerMsg.textContent = 'ðŸ† Red wins overall!';
        winnerMsg.style.color = '#dc2626';
      } else {
        winnerMsg.textContent = 'ðŸ¤ It\'s a tie overall!';
        winnerMsg.style.color = '#111';
      }
    }

    // Toggle between intro and game
    startBtn.addEventListener('click', () => {
      intro.style.display = 'none';
      game.style.display  = 'block';
      window.scrollTo(0, 0);
    });

    showStoryBtn.addEventListener('click', () => {
      game.style.display  = 'none';
      intro.style.display = 'block';
      window.scrollTo(0, 0);
    });

  </script>
</body>
</html>
