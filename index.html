<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gerrymandering Grid</title>
<style>
Â  body {
    font-family: Arial, sans-serif;
    text-align: center;
    padding: 20px;
  }
Â  .controls {
    margin-bottom: 15px;
  }
Â  .grid {
    display: grid;
    grid-template-columns: repeat(4, 60px);
    grid-template-rows: repeat(4, 60px);
    gap: 2px;
    justify-content: center;
    margin: 0 auto;
  }
Â  .cell {
    width: 60px;
    height: 60px;
    border: 1px solid #aaa;
    cursor: pointer;
    transition: 0.2s;
  }
Â  .blue { background-color: #3b82f6; } /* Tailwind blue-500 */
Â  .red { background-color: #ef4444; }Â  /* Tailwind red-500 */

Â  /* Different subgrid outlines */
Â  .subgrid-1 { outline: 5px solid black; }
Â  .subgrid-2 { outline: 5px solid green; }
Â  .subgrid-3 { outline: 5px solid yellow; }

Â  #message, #winner {
    margin-top: 15px;
    font-weight: bold;
  }
Â  #message { color: red; }
Â  #winner { color: #111; }
</style>
</head>
<body>
Â  <h1>Gerrymandering Interactive Grid</h1>
Â  <p>Select a subgrid, then click tiles to assign them. Each subgrid must be contiguous.</p>

Â  <div class="controls">
Â  Â  <label><input type="radio" name="subgrid" value="1" checked> Subgrid 1</label>
Â  Â  <label><input type="radio" name="subgrid" value="2"> Subgrid 2</label>
Â  Â  <label><input type="radio" name="subgrid" value="3"> Subgrid 3</label>
Â  </div>

Â  <div class="grid" id="grid"></div>
Â  <div id="message"></div>
Â  <div id="winner"></div>

<script>
const grid = document.getElementById('grid');
const rows = ['A', 'B', 'C', 'D'];
const cols = ['1', '2', '3', '4'];
const blueTiles = new Set(['A1', 'A3', 'B4', 'D1', 'D2', 'D3']);
let selectedSubgrid = '1';

// Build grid
rows.forEach(r => {
Â  cols.forEach(c => {
Â  Â  const id = r + c;
Â  Â  const cell = document.createElement('div');
Â  Â  cell.classList.add('cell', blueTiles.has(id) ? 'blue' : 'red');
Â  Â  cell.dataset.id = id;
Â  Â  cell.dataset.row = r;
Â  Â  cell.dataset.col = c;
Â  Â  cell.dataset.subgrid = '';
Â  Â  grid.appendChild(cell);
Â  });
});

// Handle subgrid selection
document.querySelectorAll('input[name="subgrid"]').forEach(input => {
Â  input.addEventListener('change', e => selectedSubgrid = e.target.value);
});

// Handle cell clicks
grid.addEventListener('click', e => {
Â  if (!e.target.classList.contains('cell')) return;
Â  const cell = e.target;
Â  const prev = cell.dataset.subgrid;
Â  if (prev === selectedSubgrid) {
Â  Â  // Unassign
Â  Â  cell.dataset.subgrid = '';
Â  Â  cell.classList.remove(`subgrid-${selectedSubgrid}`);
Â  } else {
Â  Â  // Assign
Â  Â  cell.dataset.subgrid = selectedSubgrid;
Â  Â  cell.classList.remove('subgrid-1', 'subgrid-2', 'subgrid-3');
Â  Â  cell.classList.add(`subgrid-${selectedSubgrid}`);
Â  }
Â  validateSubgrids();
});

// Helper to check connectivity and compute results
function validateSubgrids() {
Â  const cells = [...document.querySelectorAll('.cell')];
Â  const message = document.getElementById('message');
Â  const winnerMsg = document.getElementById('winner');
Â  message.textContent = '';
Â  winnerMsg.textContent = '';

Â  // Connectivity validation
Â  for (let subgridNum of ['1', '2', '3']) {
Â  Â  const assigned = cells.filter(c => c.dataset.subgrid === subgridNum);
Â  Â  if (assigned.length <= 1) continue; // single or none = valid

Â  Â  const coords = assigned.map(c => {
Â  Â  Â  const r = rows.indexOf(c.dataset.row);
Â  Â  Â  const cidx = cols.indexOf(c.dataset.col);
Â  Â  Â  return [r, cidx];
Â  Â  });

Â  Â  const visited = new Set();
Â  Â  const queue = [coords[0].join(',')];
Â  Â  visited.add(coords[0].join(','));

Â  Â  while (queue.length) {
Â  Â  Â  const [r, c] = queue.shift().split(',').map(Number);
Â  Â  Â  [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr, dc]) => {
Â  Â  Â  Â  const nr = r + dr, nc = c + dc;
Â  Â  Â  Â  const key = nr + ',' + nc;
Â  Â  Â  Â  if (nr < 0 || nr >= 4 || nc < 0 || nc >= 4) return;
Â  Â  Â  Â  if (!visited.has(key) && coords.some(([rr, cc]) => rr === nr && cc === nc)) {
Â  Â  Â  Â  Â  visited.add(key);
Â  Â  Â  Â  Â  queue.push(key);
Â  Â  Â  Â  }
Â  Â  Â  });
Â  Â  }

Â  Â  if (visited.size !== coords.length) {
Â  Â  Â  message.textContent = `âŒ Invalid subgrid ${subgridNum}: tiles must be connected!`;
Â  Â  Â  winnerMsg.textContent = '';
Â  Â  Â  return;
Â  Â  }
Â  }

Â  message.textContent = 'âœ… All subgrids valid.';
Â Â 
Â  // Compute subgrid winners
Â  const subgridResults = {1: null, 2: null, 3: null};
Â  for (let subgridNum of ['1', '2', '3']) {
Â  Â  const assigned = cells.filter(c => c.dataset.subgrid === subgridNum);
Â  Â  if (assigned.length === 0) continue;

Â  Â  const blueCount = assigned.filter(c => c.classList.contains('blue')).length;
Â  Â  const redCount = assigned.length - blueCount;

Â  Â  if (blueCount > redCount) subgridResults[subgridNum] = 'blue';
Â  Â  else if (redCount > blueCount) subgridResults[subgridNum] = 'red';
Â  Â  else subgridResults[subgridNum] = 'tie';
Â  }

Â  // Count overall wins
Â  const blueWins = Object.values(subgridResults).filter(v => v === 'blue').length;
Â  const redWins = Object.values(subgridResults).filter(v => v === 'red').length;

Â  if (blueWins >= 2) {
Â  Â  winnerMsg.textContent = 'ğŸ† Blue wins overall!';
Â  Â  winnerMsg.style.color = '#2563eb';
Â  } else if (redWins >= 2) {
Â  Â  winnerMsg.textContent = 'ğŸ† Red wins overall!';
Â  Â  winnerMsg.style.color = '#dc2626';
Â  } else {
Â  Â  winnerMsg.textContent = 'ğŸ¤ It\'s a tie overall!';
Â  Â  winnerMsg.style.color = '#111';
Â  }
}
</script>
</body>
</html>
