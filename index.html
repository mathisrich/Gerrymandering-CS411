<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gerrymandering Grid</title>
<style>
  body {
    font-family: Arial, sans-serif;
    text-align: center;
    padding: 20px;
  }
  .controls {
    margin-bottom: 15px;
  }
  .grid {
    display: grid;
    grid-template-columns: repeat(5, 60px);
    grid-template-rows: repeat(5, 60px);
    gap: 0;               /* tiles touch each other */
    justify-content: center;
    margin: 0 auto;
  }
  .cell {
    position: relative;
    width: 60px;
    height: 60px;
    box-sizing: border-box;
    border: 1px solid #aaa;          /* thin neutral grid line */
    cursor: pointer;
    transition: transform 0.1s;      /* press animation only */
  }
  /* Press straight down, no diagonal */
  .cell:active {
    transform: translateY(2px);
  }

  .blue { background-color: #3b82f6; }
  .red  { background-color: #ef4444; }

  #message, #winner {
    margin-top: 15px;
    font-weight: bold;
  }
  #message { color: red; }
  #winner  { color: #111; }
</style>
</head>
<body>
  <!-- Instructions screen -->
  <div id="intro" style="max-width: 700px; margin: 0 auto 20px; text-align: left;">
    <h1>Instructions for PS activity</h1>
    <p>You are McDonald Chumb, an ambitious and sharp strategist working for
       Barage Obana, a presidential candidate in a closely contested election.
       Your job: redraw the district map before the next vote.</p>

    <p>On the screen, youâ€™ll see a grid of voters, shown in two colors:
       <strong>blue</strong> and <strong>red</strong>. Each square is one voter.
       <strong>Blue</strong> voters support Barage Obana; <strong>red</strong> voters
       do not vote for Barage Obana. Your task is to divide the territory into a
       fixed number of districts. In each district, the majority color wins the seat.</p>

    <ul>
      <li><strong>Round 1 â€“ Fair map:</strong> draw districts so that the seats
          honestly reflect the overall distribution of voters.</li>
      <li><strong>Round 2 â€“ Biased map:</strong> redraw the districts to help
          your side win as many seats as possible.</li>
    </ul>

    <div style="margin-top: 20px;">
      <button id="round1Btn">Start Round 1</button>
      <button id="round2Btn" style="margin-left:10px;">Start Round 2</button>
    </div>
  </div>

  <!-- Game screen -->
  <div id="game" style="display:none;">
    <h1>Gerrymandering Interactive Grid</h1>
    <p>Blue squares are voters for <strong>Barage Obana</strong>. Red squares are voters
       who <strong>do not</strong> vote for Barage Obana.</p>
    <p>Select a district, then click tiles to assign them. Each district must be contiguous.</p>
    <p>Try to make both sides win once, play with the districts!</p>

    <p id="roundLabel" style="margin-top:10px; font-weight:bold;">
      Current Round: 1 (fair map â€“ the side with more voters should win)
    </p>

    <button id="resetBtn" style="margin-bottom:15px; padding:10px 20px; font-size:16px;">
      Reset Game
    </button>
    <button id="showStoryBtn" style="margin-bottom:15px; padding:10px 20px; font-size:16px; margin-left:10px;">
      Show story again
    </button>
    <button id="checkBtn" style="margin-bottom:15px; padding:10px 20px; font-size:16px; margin-left:10px;">
      Check
    </button>

    <div class="controls">
      <label><input type="radio" name="subgrid" value="1" checked> District 1</label>
      <label><input type="radio" name="subgrid" value="2"> District 2</label>
      <label><input type="radio" name="subgrid" value="3"> District 3</label>
    </div>

    <div id="statusBar" style="margin-top:10px; margin-bottom:5px;">
      Number of unassigned voters: <span id="unassignedCount">25</span>
    </div>

    <div class="grid" id="grid"></div>
    <div id="message"></div>
    <div id="winner"></div>
  </div>

  <script>
    const grid = document.getElementById('grid');
    const rows = ['A', 'B', 'C', 'D', 'E'];
    const cols = ['1', '2', '3', '4', '5'];
    const intro = document.getElementById('intro');
    const game = document.getElementById('game');
    const round1Btn = document.getElementById('round1Btn');
    const round2Btn = document.getElementById('round2Btn');
    const showStoryBtn = document.getElementById('showStoryBtn');
    const resetBtn = document.getElementById('resetBtn');
    const checkBtn = document.getElementById('checkBtn');
    const unassignedCountSpan = document.getElementById('unassignedCount');
    const roundLabel = document.getElementById('roundLabel');

    const blueTiles = new Set(['A1', 'A3','B3', 'B5', 'B4', 'D1', 'D2', 'D3','E3','E4','C2']);

    let selectedSubgrid = '1';
    let currentRound = 1;
    let round1Cleared = false;
    let round2Cleared = false;

    // Map from cell id (e.g. "A1") to element for fast neighbor lookup
    const cellById = {};

    // Build grid
    rows.forEach(r => {
      cols.forEach(c => {
        const id = r + c;
        const cell = document.createElement('div');
        cell.classList.add('cell', blueTiles.has(id) ? 'blue' : 'red');
        cell.dataset.id = id;
        cell.dataset.row = r;
        cell.dataset.col = c;
        cell.dataset.subgrid = '';
        grid.appendChild(cell);
        cellById[id] = cell;
      });
    });

    // Initial unassigned count
    updateUnassignedCount();

    // Lock Round 2 until Round 1 is cleared
    round2Btn.title = 'You must finish Round 1 first';
    round2Btn.style.opacity = '0.5';
    round2Btn.style.cursor = 'not-allowed';

    // Handle subgrid selection
    document.querySelectorAll('input[name="subgrid"]').forEach(input => {
      input.addEventListener('change', e => selectedSubgrid = e.target.value);
    });

    function resetBoard() {
      const cells = document.querySelectorAll('.cell');
      cells.forEach(cell => {
        cell.dataset.subgrid = '';
        cell.classList.remove('subgrid-1', 'subgrid-2', 'subgrid-3');
      });
      document.getElementById('message').textContent = '';
      document.getElementById('winner').textContent = '';
      updateDistrictBorders();
      updateUnassignedCount();
    }

    function updateRoundLabel() {
      if (currentRound === 1) {
        roundLabel.textContent =
          'Current Round: 1 (fair map â€“ the side with more voters should win)';
      } else {
        roundLabel.textContent =
          'Current Round: 2 (gerrymander â€“ try to make Barage Obana (blue) win)';
      }
    }

    function startRound(roundNumber) {
      // Only reset board when switching rounds; preserve state if re-opening same round
      if (currentRound !== roundNumber) {
        currentRound = roundNumber;
        resetBoard();
      } else {
        currentRound = roundNumber;
      }
      updateRoundLabel();
      intro.style.display = 'none';
      game.style.display  = 'block';
      window.scrollTo(0, 0);
    }

    // Round buttons in the story screen
    round1Btn.addEventListener('click', () => {
      if (round1Cleared) return; // ignore if already cleared
      startRound(1);
    });

    round2Btn.addEventListener('click', () => {
      // Block until Round 1 cleared
      if (!round1Cleared || round2Cleared) return;
      startRound(2);
    });

    // Handle cell clicks
    grid.addEventListener('click', e => {
      if (!e.target.classList.contains('cell')) return;
      const cell = e.target;
      const prev = cell.dataset.subgrid;

      const winnerMsg = document.getElementById('winner');
      winnerMsg.textContent = ''; // clear old result when user edits

      // If this tile already belongs to another district, ignore the click
      if (prev && prev !== selectedSubgrid) {
        return;
      }

      // Toggle membership for the currently selected district
      if (prev === selectedSubgrid) {
        // remove from this district
        cell.dataset.subgrid = '';
        cell.classList.remove(`subgrid-${selectedSubgrid}`);
      } else {
        // assign to this district (was unassigned)
        cell.dataset.subgrid = selectedSubgrid;
        cell.classList.add(`subgrid-${selectedSubgrid}`);
      }

      // Update connectivity info and borders live
      validateSubgrids(true);
      updateUnassignedCount();
    });

    // Reset button
    resetBtn.addEventListener('click', () => {
      resetBoard();
    });

    // Update unassigned tile counter
    function updateUnassignedCount() {
      const cells = document.querySelectorAll('.cell');
      let unassigned = 0;
      cells.forEach(c => {
        if (!c.dataset.subgrid) unassigned++;
      });
      unassignedCountSpan.textContent = unassigned;
    }

    // Update borders so that each district has a single merged outline
    function updateDistrictBorders() {
      const cells = [...document.querySelectorAll('.cell')];

      // 1) Reset all borders to thin grey grid
      cells.forEach(cell => {
        cell.style.borderTop    = '1px solid #aaa';
        cell.style.borderRight  = '1px solid #aaa';
        cell.style.borderBottom = '1px solid #aaa';
        cell.style.borderLeft   = '1px solid #aaa';
      });

      const colors = {
        1: 'black',
        2: 'rgb(0, 255, 34)',
        3: 'rgb(255, 255, 0)'
      };

      const thick = '6px';  // thicker outline

      // 2) For each district, set merged outline
      for (let subgridNum of ['1', '2', '3']) {
        const color = colors[subgridNum];
        const assigned = cells.filter(c => c.dataset.subgrid === subgridNum);
        if (assigned.length === 0) continue;

        for (const cell of assigned) {
          const rowIndex = rows.indexOf(cell.dataset.row);
          const colIndex = cols.indexOf(cell.dataset.col);

          // Helper to get neighbor
          const getCell = (ri, ci) => {
            if (ri < 0 || ri >= rows.length || ci < 0 || ci >= cols.length) return null;
            const id = rows[ri] + cols[ci];
            return cellById[id] || null;
          };

          // TOP side
          let neighbor = getCell(rowIndex - 1, colIndex);
          if (!neighbor || neighbor.dataset.subgrid !== subgridNum) {
            cell.style.borderTop = `${thick} solid ${color}`;
          } else {
            // internal edge: keep thin internal grid line
            cell.style.borderTop = '1px solid #aaa';
            neighbor.style.borderBottom = '1px solid #aaa';
          }

          // BOTTOM side
          neighbor = getCell(rowIndex + 1, colIndex);
          if (!neighbor || neighbor.dataset.subgrid !== subgridNum) {
            cell.style.borderBottom = `${thick} solid ${color}`;
          } else {
            cell.style.borderBottom = '1px solid #aaa';
            neighbor.style.borderTop = '1px solid #aaa';
          }

          // LEFT side
          neighbor = getCell(rowIndex, colIndex - 1);
          if (!neighbor || neighbor.dataset.subgrid !== subgridNum) {
            cell.style.borderLeft = `${thick} solid ${color}`;
          } else {
            cell.style.borderLeft = '1px solid #aaa';
            neighbor.style.borderRight = '1px solid #aaa';
          }

          // RIGHT side
          neighbor = getCell(rowIndex, colIndex + 1);
          if (!neighbor || neighbor.dataset.subgrid !== subgridNum) {
            cell.style.borderRight = `${thick} solid ${color}`;
          } else {
            cell.style.borderRight = '1px solid #aaa';
            neighbor.style.borderLeft = '1px solid #aaa';
          }
        }
      }
    }

    // Validate connectivity only; return true/false
    function validateSubgrids(showMessages = true) {
      const cells = [...document.querySelectorAll('.cell')];
      const message = document.getElementById('message');

      if (showMessages) {
        message.textContent = '';
      }

      // Update borders first so visual stays in sync
      updateDistrictBorders();

      for (let subgridNum of ['1', '2', '3']) {
        const assigned = cells.filter(c => c.dataset.subgrid === subgridNum);
        if (assigned.length <= 1) continue;

        const coords = assigned.map(c => {
          return [
            rows.indexOf(c.dataset.row),
            cols.indexOf(c.dataset.col)
          ];
        });

        const visited = new Set();
        const queue = [coords[0].join(',')];
        visited.add(coords[0].join(','));

        while (queue.length) {
          const [r, c] = queue.shift().split(',').map(Number);
          [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr, dc]) => {
            const nr = r + dr, nc = c + dc;
            const key = nr + ',' + nc;
            if (nr < 0 || nr >= 5 || nc < 0 || nc >= 5) return;
            if (!visited.has(key) && coords.some(([rr, cc]) => rr === nr && cc === nc)) {
              visited.add(key);
              queue.push(key);
            }
          });
        }

        if (visited.size !== coords.length) {
          if (showMessages) {
            message.textContent = `âŒ Invalid district ${subgridNum}: voters must be connected!`;
          }
          return false;
        }
      }

      if (showMessages) {
        message.textContent = 'âœ… All districts valid.';
      }
      return true;
    }

    // Compute and display winner, and return 'blue' | 'red' | 'tie'
    function computeWinner() {
      const cells = [...document.querySelectorAll('.cell')];
      const winnerMsg = document.getElementById('winner');

      const subgridResults = {1: null, 2: null, 3: null};
      for (let subgridNum of ['1', '2', '3']) {
        const assigned = cells.filter(c => c.dataset.subgrid === subgridNum);
        if (assigned.length === 0) continue;

        const blueCount = assigned.filter(c => c.classList.contains('blue')).length;
        const redCount = assigned.length - blueCount;

        if (blueCount > redCount) subgridResults[subgridNum] = 'blue';
        else if (redCount > blueCount) subgridResults[subgridNum] = 'red';
        else subgridResults[subgridNum] = 'tie';
      }

      const blueWins = Object.values(subgridResults).filter(v => v === 'blue').length;
      const redWins  = Object.values(subgridResults).filter(v => v === 'red').length;

      let winner = 'tie';
      if (blueWins > redWins && blueWins >= 2) {
        winner = 'blue';
        winnerMsg.textContent = 'ðŸ† Blue wins overall!';
        winnerMsg.style.color = '#2563eb';
      } else if (redWins > blueWins && redWins >= 2) {
        winner = 'red';
        winnerMsg.textContent = 'ðŸ† Red wins overall!';
        winnerMsg.style.color = '#dc2626';
      } else {
        winner = 'tie';
        winnerMsg.textContent = 'ðŸ¤ It\'s a tie overall!';
        winnerMsg.style.color = '#111';
      }

      return winner;
    }

    // Check button logic, with round-specific behavior
    checkBtn.addEventListener('click', () => {
      const cells = [...document.querySelectorAll('.cell')];
      const message = document.getElementById('message');
      const winnerMsg = document.getElementById('winner');

      winnerMsg.textContent = ''; // clear previous result

      const unassigned = cells.filter(c => !c.dataset.subgrid).length;
      if (unassigned > 0) {
        message.textContent = `âŒ You must assign all voters before checking. Number of unassigned voters: ${unassigned}.`;
        return;
      }

      const districtCounts = {1: 0, 2: 0, 3: 0};
      cells.forEach(c => {
        const sg = c.dataset.subgrid;
        if (sg === '1' || sg === '2' || sg === '3') {
          districtCounts[sg]++;
        }
      });
      const usedDistricts = Object.values(districtCounts).filter(count => count > 0).length;
      if (usedDistricts < 3) {
        message.textContent = 'âŒ You must use all 3 districts (each with at least one voter) before checking.';
        return;
      }

      // Connectivity check
      const ok = validateSubgrids(true);
      if (!ok) {
        // validateSubgrids already set an error message
        return;
      }

      const winner = computeWinner();

      if (currentRound === 1) {
        // Round 1: they only clear if red wins overall
        if (winner === 'red') {
          round1Cleared = true;
          message.textContent = 'âœ… Round 1 cleared: the side with more voters (red) wins.';

          // Dim and disable Round 1 button in the story screen
          round1Btn.disabled = true;
          round1Btn.textContent = 'Round 1 (cleared)';
          round1Btn.style.opacity = '0.5';
          round1Btn.style.cursor = 'not-allowed';

          // Unlock Round 2 visually/logically if not already cleared
          if (!round2Cleared) {
            round2Btn.style.opacity = '1';
            round2Btn.style.cursor = 'pointer';
            round2Btn.title = '';
          }
        } else {
          if (winner === 'tie') {
            message.textContent =
              'âŒ Hint: How many people vote for Barage Obana (blue)?' +
              'How many vote for someone else (red)? Usually, if more people want to vote for one side, ' +
              'that side should win, right?';
          } else {
            // blue wins
            message.textContent =
              'âŒ Hint: How many people vote for Barage Obana (blue)?' +
              'How many vote for someone else (red)? Usually, if more people want to vote for one side, ' +
              'that side should win, right?';
          }
        }
      } else {
        // Round 2: just show who wins with current districts
        if (winner === 'blue') {
          round2Cleared = true;
          message.textContent = 'âœ… Round 2 cleared: Barage Obana (blue) wins!';

          // Dim and disable Round 2 button in the story screen
          round2Btn.disabled = true;
          round2Btn.textContent = 'Round 2 (cleared)';
          round2Btn.style.opacity = '0.5';
          round2Btn.style.cursor = 'not-allowed';
        }
      }
    });

    // Toggle back to the story
    showStoryBtn.addEventListener('click', () => {
      game.style.display  = 'none';
      intro.style.display = 'block';
      window.scrollTo(0, 0);
    });

  </script>
</body>
</html>
